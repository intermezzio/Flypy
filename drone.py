from vector import Vector
from math import pi, cos, sin
import numpy as np

class Drone:
    """
    Drone class.

    Attributes:
        rotation: Roll, pitch and yaw stored as a vector
        rotation_velocity_bf: Roll, pitch and yaw for the body frame stored as a vector
        rotation_velocity_if: Roll, pitch and yaw for the inertial frame stored as a vector
        pos: Current drone position as a vector
        velocity: Current velocity of the drone as a vector
        r_speed: List of rotor speeds where index 0 is top left, index 1 if top
        right, index 2 is bottom left and index 3 is bottom right
                 Ex: [10, 9, 5, 8] is 10   09
                                         x
                                      05   08
        r: Radius of the drone rotors in m
        weight: Weight of the drone in g
        size: Size of the drone in m
        m_of_i_xx: Moment of inertia of the drone around the x axis
        m_of_i_zz: Moment of inertia of the drone around the z axis
        m_of_i_r: Moment of inertia of one rotor
    """
    def __init__(self,
                 rotor_radius=15,
                 weight=50,
                 size=10,
                 m_of_i_xx=1,
                 m_of_i_zz=1,
                 m_of_i_r=1):
        """
        Constructor.

        Parameters:
            rotor_radius: Radius of the drone rotors in m
            weight: Weight of the drone in g
            size: Size of the drone in m
            m_of_i_xx: Moment of inertia of the drone around the x axis
            m_of_i_zz: Moment of inertia of the drone around the z axis
            m_of_i_r: Moment of inertia of one rotor
        """
        self.rotation = Vector()
        self.rotation_velocity_bf = Vector()
        self.rotation_velocity_if = Vector()
        self.pos = Vector()
        self.velocity = Vector()
        self.r_speed = [0, 0, 0, 0]

        self.r = rotor_radius
        self.weight = weight
        self.size = size
        self.m_of_i_xx = m_of_i_xx
        self.m_of_i_zz = m_of_i_zz
        self.m_of_i_r = m_of_i_r

    def change_rotor_speed(r_speed):
        """
        Changes the speeds of the four rotors as necessary

        Parameters:
            r_speed: Array of all four rotor speeds
        """
        if len(r_speed) == 4:
            self.r_speed = r_speed

    def update(self, dt=1, g=-9.81, r_speed=None):
        """
        Calculate the change in each positional variable and apply them

        Parameters:
            dt: Timestep size
            g: Acceleration due to gravity
            r_speed: Array of all four rotor speeds
        """
        # Update rotor speeds if necessary
        if r_speed is not None:
            self.change_rotor_speed(r_speed)

        # Calculate acceleration in all 3 axis
        thrust = self.calc_thrust()
        gravity = Vector(0, 0, g)
        total_acceleration = thrust + gravity

        # Calculate change in rotations
        roll = self.calc_rotation(self.r_speed[0], self.r_speed[3])
        pitch = self.calc_rotation(self.r_speed[1], self.r_speed[2])
        yaw = self.calc_yaw()

        # Apply deltas
        self.pos += self.velocity * dt
        self.velocity += acceleration * dt

    def calc_thrust(self):
        """
        Calculates the acceleration due to thrust given current yaw / pitch /
        roll and returns a acceleration vector.

        Returns:
            Vector: Acceleration vector generated by the thrust of the rotors
        """
        total_force = sum([self.calc_rotor_force(s) for s in self.r_speed])

        # Rotate the initial force vector that is only in the Z direction by the
        # roll / pitch / yaw.
        # See this answer for reference: https://math.stackexchange.com/a/1637853
        force_matrix = np.array([[0], [0], [total_force]])
        roll_matrix = np.array([[cos(self.roll), 0, -sin(self.roll)],
                               [0, 1, 0],
                               [sin(self.roll), 0, cos(self.roll)]])
        force_matrix = np.matmul(roll_matrix, force_matrix)
        pitch_matrix = np.array([[1, 0, 0],
                                [0, cos(self.pitch), -sin(self.pitch)],
                                [0, sin(self.pitch), cos(self.pitch)]])
        force_matrix = np.matmul(pitch_matrix, force_matrix)
        yaw_matrix = np.array([[cos(self.yaw), sin(self.yaw), 0],
                              [-sin(self.yaw), cos(self.yaw), 0],
                              [0, 0, 1]])
        force_matrix = np.matmul(yaw_matrix, force_matrix)

        thrust = Vector(force_matrix[0], force_matrix[1], force_matrix[2])
        return thrust

    def calc_roll_pitch(self, front_speed, back_speed):
        """
        Calculates the roll or pitch (depending on the rotor pair selected) in
        the body frame

        Parameters:
            front_speed: The rotor speed of the front rotor of the pair being
            evaluted
            back_speed: The rotor speed of the back rotor of the pair being
            evaluted

        Returns:
            float: Angular acceleration of either roll or pitch
        """
        total_speed = -(front_speed ** 2) + (back_speed ** 2)
        total_force = self.calc_rotor_force(total_speed)
        torque = total_force * self.size

        angular_accel = torque / self.m_of_i_xx

        return angular_accel

    def calc_yaw(self, drag_coef=1):
        """
        Calculate the change in yaw

        Returns:
            float: Angular acceleration of yaw
        """
        torques = [drag_coef * (s ** 2) for s in self.r_speed]
        # Flip the direction of one diagnol of rotors to account for
        # counter-clockwise rotation
        torques[1] *= -1
        torques[2] *= -1
        total_torque = sum(torques)

        rotation = total_torque / self.m_of_i_zz

        return rotation

    def calc_rotor_force(self, speed, lift_coef=1):
        """
        Calculate the force of a rotor given a rotor speed.
        See this answer for reference: https://aviation.stackexchange.com/a/16550

        Parameters:
            speed: Speed of the rotor
            drag_coef: Drag coefficent of the rotors
            air_density: Density of the air

        Returns:
            float: Force generated by the rotor at the given speed
        """
        return lift_coef * speed

    def get_params(self):
        """
        Returns all positional attributes in a list

        Returns:
            list: Contains all positional parameters of the drone
        """
        params = [self.pos.x,
                  self.pos.y,
                  self.pos.z,
                  self.velocity.x,
                  self.velocity.y,
                  self.velocity.z,
                  self.roll,
                  self.pitch,
                  self.yaw]
        return params
