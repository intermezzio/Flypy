from vector import Vector
from math import pi, cos, sin, tan
import numpy as np

class Drone:
    """
    Drone class.

    Attributes:
        rot: Roll, pitch and yaw stored as a vector
        bf_angular_vel: Roll, pitch and yaw angular velocity for the body frame
        stored as a vector
        if_angular_vel: Roll, pitch and yaw angular velocity for the inertial
        frame stored as a vector
        pos: Current drone position as a vector
        velocity: Current velocity of the drone as a vector
        r_speed: List of rotor speeds where index 0 is top left, index 1 is top
        right, index 2 is bottom left and index 3 is bottom right
                 Ex: [10, 9, 5, 8] is 10   09
                                         x
                                      05   08
        mass: Weight of the drone in g
        size: Size of the drone in m
        m_of_i_xx: Moment of inertia of the drone around the x axis
        m_of_i_zz: Moment of inertia of the drone around the z axis
        m_of_i_r: Moment of inertia of one rotor
    """
    def __init__(self,
                 mass=0.468,
                 size=0.225,
                 m_of_i_xx=4.856e-3,
                 m_of_i_zz=8.801e-3,
                 m_of_i_r=3.357e-5):
        """
        Constructor.

        Parameters:
            mass: Weight of the drone in g
            size: Size of the drone in m
            m_of_i_xx: Moment of inertia of the drone around the x axis
            m_of_i_zz: Moment of inertia of the drone around the z axis
            m_of_i_r: Moment of inertia of one rotor
        """
        self.rot = Vector()
        self.bf_angular_vel = Vector()
        self.if_angular_vel = Vector()
        self.pos = Vector()
        self.velocity = Vector()
        self.r_speed = [0, 0, 0, 0]

        self.mass = mass
        self.size = size
        self.m_of_i_xx = m_of_i_xx
        self.m_of_i_zz = m_of_i_zz
        self.m_of_i_r = m_of_i_r

    def update(self, dt=1, g=9.81, r_speed=None):
        """
        Calculate the change in each positional variable and apply them

        Parameters:
            dt: Timestep size
            g: Acceleration due to gravity
            r_speed: Array of all four rotor speeds
        """
        # Update rotor speeds if necessary
        if r_speed is not None:
            self.change_rotor_speed(r_speed)

        # Calculate positional acceleration
        thrust = self.calc_thrust()
        gravity = Vector(0, 0, -g)
        total_acceleration = thrust + gravity

        # Calculate angular acceleration
        bf_angular_accel = self.calc_body_frame_accel()
        if_angular_accel = self.calc_inertial_frame_accel(bf_angular_accel)

        # Apply deltas
        self.pos += self.velocity * dt
        self.velocity += acceleration * dt
        self.rot += self.if_angular_vel * dt
        self.bf_angular_vel += bf_angular_accel * dt
        self.if_angular_vel += if_angular_accel * dt

    def calc_thrust(self):
        """
        Calculates the acceleration due to thrust given current yaw / pitch /
        roll and returns a acceleration vector.

        Returns:
            Vector: Acceleration vector generated by the thrust of the rotors
        """
        total_force = sum([self.calc_rotor_force(s) for s in self.r_speed])
        total_accel = total_force / self.mass

        _phi = self.rot.x
        _the = self.rot.y
        _psi = self.rot.z
        # Matrix to transform thrust from body frame to inertial frame
        t_matrix = Vector(cos(_psi) * sin(_the) * cos(_phi) + \
                          sin(_psi) + sin(_phi),
                          sin(_psi) * sin(_the) * cos(_phi) - \
                          cos(_psi) * sin(phi),
                          cos(_the) * cos(_phi))

        thrust = t_matrix * total_accel
        return thrust

    def calc_inertial_frame_accel(self, bf_angular_accel):
        """
        Calculate the inertial frame angular acceleration given the body frame
        angular acceleration.

        Parameters:
            bf_angular_accel: Body frame angular accelerration as a vector

        Returns:
            Vector: Vector of the inertial frame angular acceleration
        """
        _phi = self.rot.x
        _the = self.rot.y
        _dphi = self.if_angular_vel.x
        _dthe = self.if_angular_vel.y

        # Build matricies to rotate the angular acceleration
        accel_t_matrix = np.array([[1,
                                    sin(_phi) * tan(_the),
                                    cos(_phi) * tan(_the)],
                                   [0,
                                    cos(_phi),
                                    -sin(_phi)],
                                   [0,
                                    sin(_phi) / cos(_the),
                                    cos(_phi) / cos(_the)]])
        # Possible erros in the paper at [0, 2] where it says cos instead of
        # tan, and at [2, 1] when it says dpsi when it should be dtheta
        vel_t_matrix = np.array([[0,
                                  (_dphi * cos(_phi) * tan(_the)) + \
                                  (_dthe * sin(_phi) / cos(_the) ** 2),
                                  (-_dphi * sin(_phi) * tan(_the)) + \
                                  (_dthe * cos(_phi) / cos(_the) ** 2)],
                                 [0,
                                  -_dphi * sin(_phi),
                                  -_dphi * cos(_phi)],
                                 [0,
                                  (_dphi * cos(_phi) / cos(_the)) + \
                                  (_dthe * sin(_phi) * tan(_the) / cos(_the)),
                                  (-_dphi * sin(_phi) / cos(_the)) + \
                                  (_dthe * cos(_phi) * tan(_the) / cos(_the))]])

        accel_matrix = bf_angular_accel.numpy()
        vel_matrix = self.bf_angular_vel.numpy()

        if_angular_accel = np.matmul(accel_t_matrix, accel_matrix) + \
                           np.matmul(vel_t_matrix, vel_matrix)

        # Convert back to vector
        if_angular_accel = Vector().from_numpy(lf_angular_accel)
        return if_angular_accel

    def calc_body_frame_accel(self):
        """
        Calculate the body frame angular acceleration.

        Returns:
            Vector: Vector of the body frame angular acceleration
        """
        roll = self.calc_roll_pitch(self.r_speed[0], self.r_speed[3])
        pitch = self.calc_roll_pitch(self.r_speed[1], self.r_speed[2])
        yaw = self.calc_yaw()

        external_torques = Vector(roll, pitch, yaw)
        gyro_force = self.calc_gyro()
        cent_force = self.calc_cent()

        bf_angular_accel = cent_force - gyro_force + external_torques
        return bf_angular_accel

    def calc_cent(self):
        """
        Calculate body frame angular acceleration due to centripetal force.

        Returns:
            Vector: Vector of the body frame angular acceleration due to
            centripetal force
        """
        inertia_velocity = Vector(self.bf_angular_vel.x * self.m_of_i_xx,
                                  self.bf_angular_vel.y * self.m_of_i_xx,
                                  self.bf_angular_vel.z * self.m_of_i_zz)
        cent_force = (self.bf_angular_vel * -1).cross_product(inertia_velocity)
        return cent_force

    def calc_gyro(self):
        """
        Calculate body frame angular acceleration due to gyroscopic force.

        Returns:
            Vector: Vector of the body frame angular acceleration due to
            gyroscopic force
        """
        total_speed = sum([i if i == 0 or i == 3 else -1
                           for i in self.r_speed])
        gyro_force = Vector(self.bf_angular_vel.y / self.m_of_i_xx,
                            -self.bf_angular_vel.x / self.m_of_i_xx,
                            0)
        gyro_force *= total_speed * self.m_of_i_zz
        return gyro_force

    def calc_roll_pitch(self, front_speed, back_speed):
        """
        Calculates the angular acceleration of either the roll or pitch
        (depending on the rotor pair selected) in the body frame

        Parameters:
            front_speed: The rotor speed of the front rotor of the pair being
            evaluted
            back_speed: The rotor speed of the back rotor of the pair being
            evaluted

        Returns:
            float: Angular acceleration of either roll or pitch
        """
        total_speed = -(front_speed ** 2) + (back_speed ** 2)
        total_force = self.calc_rotor_force(total_speed)
        torque = total_force * self.size

        angular_accel = torque / self.m_of_i_xx

        return angular_accel

    def calc_yaw(self, drag_coef=1.14e-7):
        """
        Calculate the angular acceleration of yaw in the body frame

        Returns:
            float: Angular acceleration of yaw
        """
        torques = [drag_coef * (s ** 2) for s in self.r_speed]
        # Flip the direction of one diagnol of rotors to account for
        # counter-clockwise rotation
        torques[1] *= -1
        torques[2] *= -1
        total_torque = sum(torques)

        angular_accel = total_torque / self.m_of_i_zz

        return angular_accel

    def calc_rotor_force(self, speed, lift_coef=0.225):
        """
        Calculate the force of a rotor given a rotor speed.

        Parameters:
            speed: Speed of the rotor
            drag_coef: Drag coefficent of the rotors
            air_density: Density of the air

        Returns:
            float: Force generated by the rotor at the given speed
        """
        return lift_coef * speed

    def change_rotor_speed(r_speed):
        """
        Changes the speeds of the four rotors as necessary

        Parameters:
            r_speed: Array of all four rotor speeds
        """
        if len(r_speed) == 4:
            self.r_speed = r_speed

    def get_params(self):
        """
        Returns all positional attributes in a list

        Returns:
            list: Contains all positional parameters of the drone
        """
        params = [self.pos.x,
                  self.pos.y,
                  self.pos.z,
                  self.velocity.x,
                  self.velocity.y,
                  self.velocity.z,
                  self.roll,
                  self.pitch,
                  self.yaw]
        return params
